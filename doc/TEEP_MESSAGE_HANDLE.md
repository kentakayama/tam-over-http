## TAM's TEEP Message handling

### TEEP Protocol interactions defined in (Draft) RFCs

The [section 3 of TEEP Protocol](https://datatracker.ietf.org/doc/html/draft-ietf-teep-protocol-21#section-3) defines how TEEP Agents to reply messages from TAM:

```mermaid
flowchart LR
    TAM[TAM] -- QueryRequest --> TEEPAgent[TEEP Agent]
    TEEPAgent -- QueryResponse --> TAM
    TEEPAgent -- Error --> TAM
```

```mermaid
flowchart LR
    TAM[TAM] -- Update --> TEEPAgent[TEEP Agent]
    TEEPAgent -- Success --> TAM
    TEEPAgent -- Error --> TAM
```

However, in some cases the TAM cannot initiate sending the messages, for example,
the TEEP Agent (or the TEEP Broker) does not provide listening sockets,
the TAM cannot reach the TEEP Agent due to NAT traversal issues, etc.

[TEEP over HTTP](https://datatracker.ietf.org/doc/draft-ietf-teep-otrp-over-http) resolves such situations the TAM providing HTTP server to accepts messages from TEEP Agents:

```mermaid
flowchart LR
    TEEPAgent[TEEP Agent] -- "POST (empty)" --> TAM[TAM]
    TAM -- 200 OK: QueryRequest --> TEEPAgent
```

```mermaid
flowchart LR
    TEEPAgent[TEEP Agent] -- "POST QueryResponse" --> TAM[TAM]
    TAM -- 200 OK: Update --> TEEPAgent
```

```mermaid
flowchart LR
    TEEPAgent[TEEP Agent] -- "POST Success/Error" --> TAM[TAM]
    TAM -- 204 No Content: (empty) --> TEEPAgent
```

### TEEP with Remote Attestation

For the TAM to securely manage the Trusted Components inside TEEs, our TAM implementation requires Remote Attestation of TEEP Agents.
The TAM wamts to confirm following points:
1. the TEEP Agent is running inside a genuine TEE
2. the TEE softwares including TEEP Agents keep integrity and authentication
3. the signing key of TEEP Agent's was securely generated inside the TEE

To achieve these requirements,
the TEEP Agent requests the Attesting Environment (e.g. Intel SGX Quoting Enclave) to generate Evidence (e.g. SGX Quote) and sends it in QueryResponse message,
and the TAM requests the Verifier to verify it.

```mermaid
flowchart LR
    TEEPAgent[TEEP Agent] -- Evidence in QueryResponse --> TAM
    TAM -- Evidence --> Verifier
    Verifier -- Attestation Results --> TAM
```

> [!NOTE]
> The above chart is based on background-check model

In our implementation, we use customized [VERAISON](https://github.com/kentakayama/services) (the original one is under the [VERAISON project repository](https://github.com/veraison)) for Verifier to verify the SGX Quote.

```mermaid
flowchart LR
    TEEPAgent[TEEP Agent] -- SGX Quote in QueryResponse --> TAM
    TAM -- SGX Quote --> VERAISON
    VERAISON -- EAT Attestation Results --> TAM
```

Our customized VERAISON verifies that:
1. the SGX Quote has been generated by the authorized Quoting Enclave under the certificate chain from Intel Certificate Authority (CA)
2. MRENCLAVE and MRSIGNER are expected values respectively
3. the TEEP Agent bound to the MRENCLAVE is programmed generating its signing key inside TEE

While SGX Quote is defined by the products, our customized VERAISON produces Attestation Results in [IETF RATS EAT](https://datatracker.ietf.org/doc/rfc9711) format based on the [EAT Profile of TEEP Protocol](https://datatracker.ietf.org/doc/html/draft-ietf-teep-protocol#section-5).
We leverages the [Key Confirmation Claim of CWT](https://datatracker.ietf.org/doc/rfc8747/): the VERAISON extracts the TEEP Agent's key from SGX Quote Report Data and stores it inside [EAT Attestation Results](https://datatracker.ietf.org/doc/draft-ietf-rats-ear/).

TODO: SGX Quote constraction and Report Data => EAT Attestation Results conversion (external link to our customized VERAISON)

### How this TAM implementation Acts

Based on these (draft) RFCs, we implemented this TAM over HTTP as following:

```mermaid
---
title: TAM's TEEP Message handling
---

flowchart TD
    Start([POST /tam endpoint])
    IsEmpty{{Is empty?}}
    SendQueryRequestWithToken(["OK: Return QueryRequest message<br/>(token, request-tc-list)"])
    SendQueryRequestWithChallenge(["OK: Return QueryRequest message<br/>(challenge, request-attestation)"])
    Verify{{Verified with stored Agent keys?}}
    IsResponse{{Is QueryResponse message?}}
    SwitchMessage{{"Switch {QueryResponse, Success, Error}"}}
    ProcessSuccess[Process Success message]
    ProcessError[Process Error message]
    AttestationExists{{Does attestation-payload exist?}}
    ProcessAttestation[Query Evidence Verification]
    AttestationOK{{"Is AttestationResult 'affirming'?"}}
    VerifyAgain{{Verified QueryResponse with confirmed key?}}
    StoreKey[Store Agent key]
    ProcessQueryResponseMessage["Process QueryResponse message"]
    ReplyUpdate(["OK: Return Update message<br/>(manifests)"])
    BadMessage([Failure: Return empty])
    SuccessNoReply([OK: Return empty])

    Start --> IsEmpty
    IsEmpty -- YES --> SendQueryRequestWithToken
    IsEmpty -- NO --> Verify
    Verify -- OK --> SwitchMessage
    SwitchMessage -- Success --> ProcessSuccess
    ProcessSuccess --> SuccessNoReply
    SwitchMessage -- Error --> ProcessError
    ProcessError --> SuccessNoReply
    SwitchMessage -- QueryResponse --> ProcessQueryResponseMessage
    Verify -- NO --> IsResponse
    IsResponse -- YES --> AttestationExists
    AttestationExists -- NO --> SendQueryRequestWithChallenge
    AttestationExists -- YES --> ProcessAttestation
    ProcessAttestation --> AttestationOK
    AttestationOK -- YES --> VerifyAgain
    AttestationOK -- NO --> BadMessage
    VerifyAgain -- OK --> StoreKey
    VerifyAgain -- NO --> BadMessage
    StoreKey --> ProcessQueryResponseMessage
    ProcessQueryResponseMessage --> ReplyUpdate

    IsResponse -- NO --> BadMessage
```
